# LLM 开发与 Token 机制核心要点归纳 (v2.0) Gemini 3.0 Pro 

## 1. Token 计算机制与误差
*   **预估 vs 实际**：实际消耗（`usage` 字段）通常少于前端预估。原因在于新一代 Tokenizer 对空格/特殊字符的清洗及常用词合并。
*   **可见 vs 不可见（思维链）**：接收到的 Token 数可能远大于可见文本。模型内部的“推理过程（Chain of Thought）”会计入 Output Token 账单，但用户不可见。

## 2. 上下文滚雪球效应 (Context Snowballing)
*   **无状态特性 (Stateless)**：LLM API 是无状态的，模型不记忆上一轮对话。
*   **数据验证（实验案例）**：
    *   根据你的实验数据：`105 (Input) -> 264 (Output) -> 369 (Input) -> 557 (Output) -> 662...`
    *   **现象**：虽然每次新输入的 Prompt 只有 105 Token，但输入总数在不断暴涨。
    *   **原理**：`第N轮输入 = 历史所有对话总和 + 当前新Prompt`。你是在不断地把“旧历史”重新发给模型。
*   **增量规律**：输入端的跳涨幅度（Delta）始终是你当前输入的长度（105），但**底座（Base）**在不断变高。

## 3. 平台界面解读 (AI Studio)
*   **顶部数字的含义**：**当前快照 (Snapshot)**。
    *   它代表：“如果现在点击发送，这一单请求的大小”。
    *   它**不**代表历史累积的计费总额。
*   **误区纠正**：
    *   **误解**：“因为输入一样，所以命中缓存，不计费。”
    *   **真相**：只要数字显示增加了（如 264 -> 369），就说明模型**重新阅读**了这 369 个 Token。标准 API 调用中，重复发送的内容会被**重复计算和收费**。

## 4. 成本核心概念：快照 vs 累积
为了理解计费，可以使用**“超市购物篮”类比**：

*   **第 1 轮**：篮子里放了1瓶水。
    *   *界面显示 1 瓶，你需要付 1 瓶的钱。*
*   **第 2 轮**：为了延续对话，你必须把第 1 瓶水重新放进篮子，再加第 2 瓶水。
    *   *界面显示 2 瓶（快照），但你这一轮要付 2 瓶的钱。*
*   **总成本**：不是最后一次显示的数字，而是**每一次显示的数字相加**。
    *   $$TotalCost = Cost(Round 1) + Cost(Round 2) + ... + Cost(Round N)$$

## 5. 成本优化策略
*   **自动方案**：滑动窗口（Sliding Window），只保留最近 N 轮，丢弃早期数据。
*   **人工方案（手动存档）**：
    1.  要求模型总结当前对话。
    2.  复制总结。
    3.  **清空上下文/开启新对话**（将购物篮倒空）。
    4.  粘贴总结作为背景，继续对话。

## 6. 实验工具 (Benchmark Prompt)
用于验证计数器和观察滚雪球效应的定长文本（约 100 Tokens）：

```text
Task: Ignore previous context. Reply with a nonsense text block that is exactly 100 tokens long.

[Filler Text for ~100 Token Input validation]: alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho sigma tau upsilon phi chi psi omega one two three four five six seven eight nine ten.
```
# ____________________

# Claude Opus 4.5的分析

## 1. Token 计算机制与误差
*   **预估 vs 实际**：实际消耗（如 1520）通常少于预估（如 1700）。
    *   **原因**：新一代分词器（Tokenizer）效率提升（合并常用词/代码关键字）以及传输过程中的格式/空格清洗。
*   **可见 vs 不可见（Output）**：接收到的 Token 数（如 2501）可能远大于可见文本（几百字）。
    *   **原因**：模型启用了**思维链（Chain of Thought/Reasoning）**。模型内部的思考、草稿过程会计入 Output Token 账单，但用户不可见。
*   **数据来源**：Token 统计并非前端估算，而是由后端 API 响应中的 `usage` 字段精确返回。

## 2. 上下文滚雪球效应 (Context Snowballing)
*   **无状态特性**：LLM API（HTTP）是无状态的。模型不记忆上一轮对话。
*   **发送逻辑**：为了维持"对话感"，每一轮请求**必须**包含：
    $$TotalInput = \text{System Prompt} + \text{所有历史对话(User+AI)} + \text{当前新问题}$$
*   **成本趋势**：随着对话轮数增加，Input Token 呈线性增长。越往后，你为之前的历史记录重复付费的成本越高。

## 3. 平台特性 (Google / AI Studio)
*   **AI Studio 计数器**：顶部的 Token 数字代表**"当前上下文大小"**（即如果现在点击发送，这一单的大小），而非历史累计消耗。
*   **Context Caching（上下文缓存）**：Google (Gemini 1.5) 支持该技术，可缓存长 System Prompt 或历史记录以降低 Input 费用。但在普通聊天模式下通常默认关闭，需要通过 API 显式配置。

## 4. 成本优化与开发策略
### 自动方案（代码实现）
*   **滑动窗口 (Sliding Window)**：只保留最近 N 轮对话，丢弃过早的记录。
*   **后台自动总结**：当历史记录达到阈值，后台触发任务将旧对话压缩为"摘要"。

### 人工方案（手动存档）
*   **操作**：要求模型"总结当前所有关键信息" $\rightarrow$ 复制总结 $\rightarrow$ 开启新对话 $\rightarrow$ 粘贴总结作为背景。
*   **效果**：Input Token 瞬间清零重置，仅保留核心精华。

## 5. 实验工具
用于观察 Token 增长趋势的定长 Prompt（约 100 Tokens）：

```text
Task: Ignore previous context. Reply with a nonsense text block that is exactly 100 tokens long. Do not generate less or more.

To ensure this input prompt itself equals approximately 100 tokens for your counter validation, I am adding this filler text: alpha beta gamma delta epsilon zeta eta theta iota kappa lambda mu nu xi omicron pi rho sigma tau upsilon phi chi psi omega one two three four five six seven eight nine ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen twenty.
```
~~~

---

## 助手

你好！这份总结整理得相当系统和清晰。我可以基于此与你讨论。

先简单给出一些初步反馈：

---

## 总结的准确性评估

**核心概念准确的部分：**
- 无状态 + 上下文累积发送机制 ✓
- 滚雪球效应的成本分析 ✓
- 滑动窗口 / 摘要压缩的优化策略 ✓
- Context Caching 需要显式配置 ✓

**值得补充或澄清的点：**

| 主题 | 补充说明 |
|------|----------|
| **隐藏思维链** | 这主要出现在**推理型模型**（如 OpenAI 的 o1/o3 系列）。普通模型（GPT-4o、Claude 3.5、Gemini Pro）的 output tokens 通常 ≈ 可见文本 tokens |
| **Context Caching** | 不只 Google 支持——Anthropic 也提供 **Prompt Caching**，OpenAI 对长 system prompt 有类似优化 |
| **分词器差异** | 不同厂商/模型使用不同 tokenizer，同样的文本在 GPT-4 和 Claude 中可能产生不同 token 数 |

---

## 你想讨论的方向？

可以从几个角度展开：

1. **技术深挖**：某个机制的实现细节（如 KV-cache、Prompt Caching 原理）
2. **实践问题**：你正在开发中遇到的具体场景
3. **成本优化**：针对特定用例的策略权衡
4. **勘误/验证**：你对总结中某些点存疑，想交叉验证

你对哪个方向比较感兴趣，或者有具体问题想展开？

---

## 用户

我对这个人工方案就是手动存档的这一部分有兴趣，请展开为我详细说明。

---

## 助手

# 手动存档方案详解

## 为什么需要手动存档？

回顾滚雪球效应：

```
第1轮: [System] + [Q1] + [A1]                     → 500 tokens
第5轮: [System] + [Q1-A1] + [Q2-A2] + ... + [Q5]  → 2500 tokens
第10轮: ...                                        → 5000+ tokens
```

每一轮你都在为**所有历史记录重复付费**。手动存档就是人为打断这个循环。

---

## 核心操作流程

```
┌─────────────────────────────────────────────────────────────┐
│                        旧对话窗口                            │
├─────────────────────────────────────────────────────────────┤
│  ... 10轮对话，累计 5000 tokens ...                          │
│                                                             │
│  You: 请总结我们目前为止讨论的所有关键信息，                    │
│       包括背景、已确定的结论、待解决的问题。                    │
│                                                             │
│  AI:  [生成结构化总结，约 300-500 tokens]                    │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼ 复制总结
                            
┌─────────────────────────────────────────────────────────────┐
│                        新对话窗口                            │
├─────────────────────────────────────────────────────────────┤
│  You: 以下是我们之前讨论的背景总结：                           │
│       [粘贴总结]                                             │
│       ---                                                   │
│       现在请继续，我的新问题是...                              │
│                                                             │
│  → 此时 Input 仅约 400 tokens，而非 5000                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 总结请求的 Prompt 设计

### 通用模板

```text
请总结我们目前为止的完整对话，输出结构如下：

1. **项目背景**：我们在做什么
2. **已确定事项**：达成共识的结论、已做的决定
3. **关键细节**：重要的技术参数、约束条件、代码片段
4. **当前进度**：进行到哪一步
5. **待解决问题**：尚未完成或存疑的点

要求：
- 信息完整，足以让一个新的AI助手无缝接手
- 保留必要的专有名词、数字、代码
- 省略闲聊、试错过程、重复内容
```

### 针对不同场景的变体

| 场景 | 额外要求 |
|------|----------|
| **代码开发** | 保留：文件结构、函数签名、已知 bug、技术栈版本 |
| **写作/创意** | 保留：风格要求、人物设定、已确定的大纲、关键措辞 |
| **问题排查** | 保留：已尝试方案、失败原因、环境信息 |
| **学习讨论** | 保留：已理解的概念、仍困惑的点、使用的类比 |

---

## 实际示例

### 存档前（请求总结）

```text
You: 我们讨论了很多，请帮我总结一下关键信息，以便我开新对话继续。
```

### AI 输出的总结

```text
## 对话总结

**背景**：用户正在开发一个 Chrome 扩展，用于自动提取网页正文。

**技术栈**：Manifest V3, TypeScript, Readability.js

**已完成**：
- 基础结构搭建完毕
- content script 能正确注入
- 使用 Readability.js 提取正文成功

**当前问题**：
- 在 SPA 页面（如 React 应用）中，URL 变化但 content script 不重新触发
- 尝试过 `chrome.webNavigation.onHistoryStateUpdated`，但权限配置有问题

**下一步**：需要解决 manifest.json 中的权限声明
```

### 新对话开场

```text
You: 以下是之前讨论的背景：

[粘贴上述总结]

---

现在继续。关于 manifest.json 权限问题，我加了 "webNavigation" 
但控制台报错：Unchecked runtime.lastError...
```

---

## 优缺点分析

| 优点 | 缺点 |
|------|------|
| Token 成本瞬间降低 80-90% | 需要人工操作，打断心流 |
| 强迫整理思路，发现遗漏 | 总结可能丢失某些细节 |
| 总结本身可作为文档留存 | 依赖模型总结质量 |
| 无需任何代码/工具 | 无法自动化 |

---

## 进阶技巧

### 1. 分层存档

长项目可以维护多级总结：
```
L1: 项目总背景（很少变化）       → 50 tokens
L2: 当前阶段目标和约束           → 100 tokens  
L3: 最近 2-3 轮的详细上下文      → 300 tokens
```

### 2. 存档到外部文件

```markdown
# project-context.md

## 基础背景
...

## 更新日志
- 2024-01-15: 解决了 X 问题
- 2024-01-16: 确定使用 Y 方案

## 当前状态
...
```

每次开新对话时粘贴此文件内容。

### 3. 判断存档时机

一般在以下情况考虑存档：
- Token 数接近模型上下文窗口的 50%
- 明显感觉响应变慢（可能在处理大上下文）
- 完成一个子任务，准备进入下一阶段
- 发现对话中有大量试错记录可以清理

---

还有什么具体环节想进一步了解吗？比如如何评估总结质量，或者不同平台的操作差异？

---

## 用户

关于分层存档，请为我展开并举例说明。

---

## 助手

# 分层存档详解

## 核心思想

不同信息有不同的**变化频率**和**生命周期**：

```
┌─────────────────────────────────────────────────────────┐
│  L1 - 项目背景        几乎不变        更新频率: 每周/每月  │
├─────────────────────────────────────────────────────────┤
│  L2 - 阶段目标        偶尔变化        更新频率: 每1-2天    │
├─────────────────────────────────────────────────────────┤
│  L3 - 即时上下文      频繁变化        更新频率: 每次对话   │
└─────────────────────────────────────────────────────────┘
```

将它们分开管理，可以：
- 避免每次都重复输入稳定信息
- 灵活控制每层的详细程度
- 清晰追踪项目演进

---

## 各层定义与内容

### L1：项目背景层（Project Context）

**特点**：建立后很少修改，像是项目的"宪法"

**包含内容**：
- 项目是什么、最终目标
- 技术栈 / 工具选型
- 硬性约束和边界条件
- 核心术语定义

**Token 预算**：50-150 tokens

---

### L2：阶段目标层（Phase Context）

**特点**：每完成一个里程碑更新一次

**包含内容**：
- 当前阶段的具体目标
- 已完成的里程碑（简述）
- 当前阶段的约束 / 依赖
- 阶段性的设计决策

**Token 预算**：100-300 tokens

---

### L3：即时上下文层（Session Context）

**特点**：每次对话结束时更新或重置

**包含内容**：
- 最近 2-3 轮的关键讨论
- 当前卡住的具体问题
- 刚产生的代码片段 / 草稿
- 下一步的具体行动

**Token 预算**：200-500 tokens

---

## 完整示例：待办事项 App 开发

假设你在开发一个跨平台待办事项应用，项目持续数周。

### L1 文档（project-background.md）

```markdown
# 项目背景

## 目标
开发一个跨平台待办事项应用，支持 Web 和移动端。

## 技术栈
- 前端：React Native (Expo)
- 后端：Supabase (PostgreSQL + Auth + Realtime)
- 状态管理：Zustand
- 语言：TypeScript

## 硬性约束
- 必须支持离线使用，上线后同步
- 目标用户为个人，不考虑团队协作
- 初期只做中文版

## 术语
- "Task"：单条待办
- "List"：任务分组（如"工作"、"生活"）
```

> 这份文档可能**一个月都不会改动**

---

### L2 文档（current-phase.md）

```markdown
# 当前阶段：离线同步功能

## 阶段目标
实现本地 SQLite 与 Supabase 的双向同步。

## 已完成
- [x] 本地 SQLite 数据库 schema 设计
- [x] CRUD 操作封装完成
- [x] 基础 UI 可正常增删任务（纯本地）

## 当前里程碑
实现"上线时上传本地变更"功能。

## 本阶段技术决策
- 使用 `last_modified` 时间戳做冲突检测
- 冲突策略：服务端优先，本地变更存入冲突队列供用户手动处理
- 同步触发点：App 进入前台 + 手动刷新

## 依赖 / 阻塞
- Supabase 免费套餐的 Realtime 连接数限制（最多 200）
```

> 这份文档**每完成一个功能模块更新一次**（几天一更）

---

### L3 文档（session-context.md）

```markdown
# 今日进展 (2024-01-16)

## 当前问题
实现上传队列时，遇到 Supabase upsert 批量操作的问题：
- 单条 upsert 正常
- 批量 upsert 时，部分记录的 `updated_at` 没有自动更新

## 已尝试
1. 使用 `onConflict: 'id'` → 无效
2. 手动设置 `updated_at: new Date()` → 有效但感觉不对

## 相关代码片段
```typescript
const { error } = await supabase
  .from('tasks')
  .upsert(pendingTasks, { onConflict: 'id' })
```

## 下一步
确认 Supabase 的 upsert 行为是否需要配合数据库 trigger。
```

> 这份文档**每次对话结束时更新**，或直接开新对话时重写

---

## 实际使用方式

### 场景 A：日常开发对话

```text
You: 
[粘贴 L1]
[粘贴 L2]
[粘贴 L3]

---
继续昨天的问题。我查了 Supabase 文档，发现需要用 SQL trigger，
但不确定怎么写，能帮我看看吗？
```

**Token 消耗**：约 50 + 150 + 300 = 500 tokens（而非完整历史的 5000+）

---

### 场景 B：进入新阶段

当离线同步功能完成后：

1. **更新 L2**：
```markdown
# 当前阶段：推送通知功能

## 阶段目标
实现任务到期提醒的本地推送。

## 已完成（历史阶段）
- 阶段1：基础 CRUD ✓
- 阶段2：离线同步 ✓   ← 新增

## 当前里程碑
...
```

2. **清空 L3**（旧的同步问题已无关）

3. **L1 保持不变**

---

### 场景 C：换 AI 平台 / 换模型

因为分层存档是**纯文本文件**，可以无缝切换到任何平台：

```text
[在 Claude 中开启新对话]

You:
我正在进行一个开发项目，以下是背景信息：

## 项目背景
[粘贴 L1]

## 当前阶段
[粘贴 L2]

## 即时上下文
[粘贴 L3]

---
请帮我继续...
```

---

## 各层更新策略总结

| 层级 | 更新时机 | 操作方式 |
|------|----------|----------|
| L1 | 技术栈变更、核心需求调整 | 手动编辑文件 |
| L2 | 完成一个里程碑、进入新阶段 | 手动编辑文件 |
| L3 | 每次对话结束前 | 让 AI 生成总结 → 覆盖旧内容 |

---

## 文件组织建议

```
my-project/
├── docs/
│   ├── ai-context/
│   │   ├── L1-project-background.md
│   │   ├── L2-current-phase.md
│   │   └── L3-session-context.md
│   └── ...
├── src/
└── ...
```

将上下文文档纳入项目目录，随时可取用。

---

## 进阶：快速启动模板

可以准备一个"开场白模板"：

```text
我正在进行一个开发项目，请基于以下背景与我协作：

# L1 - 项目背景
[粘贴]

# L2 - 当前阶段  
[粘贴]

# L3 - 即时上下文
[粘贴]

---

我的问题是：
[写新问题]
```

每次新对话只需填空粘贴。

---

有其他想深入的点吗？比如：
- 如何让 AI 帮你自动生成/更新各层文档
- 不同类型项目（写作、学习）的分层设计差异

---

## 用户

我想知道如何让AI帮我自动生成，更新各层文档。

接下来我想知道项目应该如何进行模块化的拆分，以保证某个功能模块，已经测试完成之后，不会被之后，新功能的加入改变它的内容。
我不太知道应该如何形容，就比如说我制作一个网页应用，它有不同的功能。然后实现这个不同区的功能需要不同的这个模块化的脚本，然后我希望采取完成一个任务之后，就锁定它当前的状态。你保证后续的变动，不会因为常上下的幻觉，对它进行修改而又引出。新的故障。

---

## 助手

# AI 辅助文档管理 + 模块化防护策略

---

# 第一部分：让 AI 自动生成/更新各层文档

## 生成 L1（项目背景）的 Prompt

在项目初期，用自然语言描述需求后：

```text
基于我们刚才的讨论，请帮我生成一份 **项目背景文档**，我将在后续所有对话中复用它。

格式要求：
## 项目目标
（一句话描述这个项目是什么、解决什么问题）

## 技术栈
（列出确定使用的语言、框架、工具、服务）

## 硬性约束
（必须满足的条件：平台限制、性能要求、兼容性等）

## 核心术语
（项目中的专有名词及其定义，避免后续歧义）

---
要求：
- 控制在 150 tokens 以内
- 只写已确定的内容，不确定的不要写
- 足够让一个新 AI 助手理解项目全貌
```

---

## 生成 L2（阶段目标）的 Prompt

当进入新阶段时：

```text
我们即将开始项目的新阶段。请帮我生成一份 **阶段目标文档**。

格式要求：
## 当前阶段名称
（如：用户认证模块 / 数据同步功能 / UI 重构）

## 阶段目标
（本阶段结束时应达成的具体成果）

## 已完成的历史阶段
（简要列出之前完成的阶段，每阶段一行）

## 本阶段技术决策
（本阶段特有的方案选择、设计决定）

## 已知依赖/风险
（外部依赖、潜在阻塞点）

---
要求：
- 控制在 200 tokens 以内
- 可作为独立文档阅读，不依赖对话上下文
```

---

## 生成/更新 L3（即时上下文）的 Prompt

每次对话结束前：

```text
请总结我们今天的对话，生成一份 **即时上下文文档**，供下次对话继续使用。

格式要求：
## 日期
（今天的日期）

## 本次完成
（已解决的问题、已写好的代码/功能）

## 当前状态
（进行到哪一步、代码目前能运行到什么程度）

## 未解决问题
（卡住的点、需要继续研究的问题）

## 关键代码/配置片段
（如果有重要代码，保留核心部分）

## 下一步行动
（明确的下一步操作）

---
要求：
- 控制在 300 tokens 以内
- 具体、可执行，避免模糊描述
- 删除今天对话中的试错过程和废弃方案
```

---

## 更新已有文档的 Prompt

当需要更新而非重写时：

```text
以下是我当前的 L2 阶段文档：

"""
[粘贴现有 L2 内容]
"""

请根据今天的进展更新它：
- 将"XX功能"从"进行中"改为"已完成"
- 添加新发现的约束：[描述]
- 其他内容保持不变

输出完整的更新后文档。
```

---

## 自动化工作流示意

```
对话开始
    │
    ├─→ 粘贴 L1 + L2 + L3
    │
    ▼
  正常对话
    │
    ▼
对话结束前
    │
    ├─→ 发送 L3 更新 Prompt
    │         │
    │         ▼
    │      AI 输出新 L3
    │         │
    │         ▼
    │      复制 → 覆盖 L3-session-context.md
    │
    ├─→ 如果完成了里程碑：发送 L2 更新 Prompt
    │
    └─→ 如果技术栈/约束变化：更新 L1（罕见）
```

---

---

# 第二部分：模块化拆分与代码锁定策略

## 你描述的问题本质

```
┌─────────────────────────────────────────────────────────────┐
│  第 1 天：完成模块 A，测试通过 ✓                              │
│  第 2 天：开发模块 B，AI 顺手"优化"了模块 A → 模块 A 坏了      │
│  第 3 天：修模块 A 时，AI 又动了模块 B → 两个都坏了            │
└─────────────────────────────────────────────────────────────┘
```

这是 AI 辅助开发的常见陷阱：
- AI 没有真正的"记忆"，不知道模块 A 已锁定
- AI 倾向于"整体优化"，容易越界修改
- 长上下文中 AI 可能产生幻觉，混淆不同模块

---

## 解决方案概览

```
┌─────────────────────────────────────────────────────────────┐
│                        防护层级                              │
├─────────────────────────────────────────────────────────────┤
│  1. 文件结构隔离     → 物理上分开，减少 AI 接触机会            │
│  2. 接口契约定义     → 只暴露接口，隐藏实现                    │
│  3. Prompt 显式声明  → 明确告诉 AI 哪些不能动                 │
│  4. 版本控制兜底     → Git 作为最后安全网                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 策略 1：文件结构隔离

### 推荐的项目结构

```
src/
├── modules/
│   ├── auth/                 ← 模块 A：用户认证
│   │   ├── auth.service.ts
│   │   ├── auth.types.ts
│   │   └── README.md         ← 模块说明 + 锁定状态
│   │
│   ├── tasks/                ← 模块 B：任务管理
│   │   ├── task.service.ts
│   │   ├── task.types.ts
│   │   └── README.md
│   │
│   └── sync/                 ← 模块 C：数据同步
│       └── ...
│
├── shared/                   ← 公共工具（谨慎修改）
│   ├── utils.ts
│   └── constants.ts
│
└── app/                      ← 主应用（组装各模块）
    └── main.ts
```

### 核心原则

| 原则 | 说明 |
|------|------|
| **一个模块 = 一个文件夹** | 物理隔离，AI 难以"顺手"修改其他文件夹 |
| **模块间只通过接口通信** | 不直接访问其他模块的内部实现 |
| **每个模块有 README** | 记录状态、接口、锁定信息 |

---

## 策略 2：接口契约定义

### 为每个模块定义明确的接口文件

```typescript
// modules/auth/auth.types.ts

/** 
 * ========== 模块状态 ==========
 * 状态：已锁定 ✓
 * 最后测试：2024-01-15
 * 负责功能：用户登录、注册、Token 管理
 * ==============================
 */

// ===== 对外暴露的接口 =====

export interface AuthService {
  login(email: string, password: string): Promise<AuthResult>;
  logout(): Promise<void>;
  getCurrentUser(): User | null;
  isAuthenticated(): boolean;
}

export interface AuthResult {
  success: boolean;
  user?: User;
  error?: string;
}

export interface User {
  id: string;
  email: string;
  name: string;
}
```

### 与 AI 对话时只提供接口

```text
我的项目中有一个已完成的 Auth 模块，它的接口如下：

"""
[只粘贴 auth.types.ts 的接口定义]
"""

现在我要开发 Task 模块，需要调用 Auth 模块判断登录状态。
请只编写 Task 模块的代码，使用上述接口，不要修改 Auth 模块。
```

**关键**：不给 AI 看 `auth.service.ts` 的实现代码，它就无法"优化"它。

---

## 策略 3：Prompt 显式声明

### 在上下文中标注模块状态

将模块状态加入 L2 文档：

```markdown
## 模块状态清单

| 模块 | 状态 | 说明 |
|------|------|------|
| auth/ | 🔒 已锁定 | 登录注册功能，已测试通过，禁止修改 |
| tasks/ | 🔒 已锁定 | CRUD 功能，禁止修改 |
| sync/ | 🚧 开发中 | 当前正在开发，可以修改 |
| shared/utils | 🔒 已锁定 | 公共函数，修改需特别说明理由 |
```

### 强调性 Prompt 模板

每次对话开始时加入：

```text
重要规则：
1. 标记为 🔒 的模块禁止修改，只能调用其接口
2. 如果你认为需要修改已锁定模块，先停下来问我
3. 只输出当前开发模块的代码
4. 不要为了"优化"而重构其他模块
```

### 任务限定 Prompt

```text
当前任务：为 sync 模块实现 uploadPendingTasks 函数

范围限制：
- 只能修改 src/modules/sync/ 下的文件
- 可以导入 auth 和 tasks 模块的接口，但不能修改它们
- 如果发现需要改其他模块才能完成，停下来告诉我

现在请开始。
```

---

## 策略 4：Git 版本控制兜底

### 完成模块后的操作流程

```bash
# 1. 模块开发完成，测试通过
npm test -- --module auth

# 2. 提交并打标签
git add src/modules/auth/
git commit -m "feat(auth): 完成认证模块"
git tag -a auth-v1.0-locked -m "Auth模块已锁定，测试通过"

# 3. 记录锁定状态
echo "AUTH_LOCKED=2024-01-15" >> .module-status
```

### 发现问题时的回滚

```bash
# 如果 AI 意外修改了 auth 模块，可以恢复
git checkout auth-v1.0-locked -- src/modules/auth/

# 或者查看被改了什么
git diff auth-v1.0-locked -- src/modules/auth/
```

---

## 策略 5：模块 README 模板

每个模块文件夹下放置 `README.md`：

```markdown
# Auth 模块

## 状态
🔒 **已锁定** (2024-01-15)

## 功能描述
处理用户认证相关功能：登录、注册、登出、Token 管理。

## 对外接口
见 `auth.types.ts`

## 使用示例
```typescript
import { authService } from '@/modules/auth';

// 登录
const result = await authService.login('user@example.com', 'password');

// 检查登录状态
if (authService.isAuthenticated()) {
  const user = authService.getCurrentUser();
}
```

## 依赖
- Supabase Auth

## 测试覆盖
- [x] 登录成功
- [x] 登录失败（密码错误）
- [x] 登出
- [x] Token 过期自动刷新

## 修改历史
- 2024-01-10: 初始版本
- 2024-01-15: 添加 Token 刷新，锁定
```

---

## 完整工作流示例

```
┌─────────────────────────────────────────────────────────────┐
│                     开发 Auth 模块                           │
├─────────────────────────────────────────────────────────────┤
│  1. 与 AI 协作开发 auth/ 下所有代码                          │
│  2. 本地测试通过                                             │
│  3. git commit + git tag auth-v1.0-locked                   │
│  4. 更新 auth/README.md 状态为 🔒                            │
│  5. 在 L2 文档中标记 auth: 已锁定                            │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                     开发 Tasks 模块                          │
├─────────────────────────────────────────────────────────────┤
│  对话开始时：                                                │
│                                                             │
│  """                                                        │
│  [粘贴 L1 + L2]                                             │
│                                                             │
│  已锁定模块接口（只读）：                                     │
│  - Auth: [粘贴 auth.types.ts]                               │
│                                                             │
│  当前任务：开发 Tasks 模块                                   │
│  可修改范围：仅 src/modules/tasks/                           │
│  """                                                        │
│                                                             │
│  → AI 只能看到 Auth 接口，无法修改其实现                       │
└─────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────┐
│                   Tasks 模块完成后                           │
├─────────────────────────────────────────────────────────────┤
│  重复：测试 → commit → tag → 更新 README → 更新 L2           │
└─────────────────────────────────────────────────────────────┘
```

---

## 常用提示语速查

| 场景 | Prompt 片段 |
|------|-------------|
| **限定范围** | `只能修改 src/modules/X/ 下的文件` |
| **禁止修改** | `Auth 模块已锁定，禁止修改，只能调用` |
| **要求确认** | `如果认为需要改已锁定模块，先告诉我原因` |
| **只看接口** | `以下是 Auth 模块的接口（实现细节省略）` |
| **防止越界** | `不要为了优化而重构其他模块` |

---

还有具体想深入的点吗？例如：
- 某个具体项目类型的模块拆分示例
- 如何设计模块间的接口通信
- 当确实需要修改已锁定模块时的安全流程
